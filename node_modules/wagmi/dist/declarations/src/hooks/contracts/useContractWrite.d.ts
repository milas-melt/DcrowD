import { WriteContractArgs, WriteContractResult } from '@wagmi/core';
import { Abi } from 'abitype';
import { MutationConfig } from '../../types';
export declare type UseContractWriteArgs<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = WriteContractArgs<TAbi, TFunctionName, {
    isAbiOptional: true;
    isAddressOptional: true;
    isArgsOptional: true;
    isFunctionNameOptional: true;
    isRequestOptional: true;
}>;
export declare type UseContractWriteConfig<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = MutationConfig<WriteContractResult, Error, UseContractWriteArgs> & UseContractWriteArgs<TAbi, TFunctionName>;
declare type UseContractWriteMutationArgs<Mode extends 'prepared' | 'recklesslyUnprepared', TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string> = Mode extends 'prepared' ? undefined : {
    /**
     * Recklessly pass through unprepared config. Note: This has
     * [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks),
     * it is highly recommended to not use this and instead prepare the config upfront
     * using the `usePrepareContractWrite` function.
     */
    recklesslySetUnpreparedArgs?: WriteContractArgs<TAbi, TFunctionName>['args'];
    recklesslySetUnpreparedOverrides?: WriteContractArgs<TAbi, TFunctionName>['overrides'];
};
/**
 * @description Hook for calling an ethers Contract [write](https://docs.ethers.io/v5/api/contract/contract/#Contract--write)
 * method.
 *
 * It is highly recommended to pair this with the [`usePrepareContractWrite` hook](/docs/prepare-hooks/usePrepareContractWrite)
 * to [avoid UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).
 *
 * @example
 * import { useContractWrite, usePrepareContractWrite } from 'wagmi'
 *
 * const { config } = usePrepareContractWrite({
 *  address: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',
 *  abi: wagmigotchiABI,
 *  functionName: 'feed',
 * })
 * const { data, isLoading, isSuccess, write } = useContractWrite(config)
 *
 */
export declare function useContractWrite<TAbi extends Abi | readonly unknown[], TFunctionName extends string>({ address, args, chainId, abi, functionName, mode, overrides, request, onError, onMutate, onSettled, onSuccess, }?: UseContractWriteConfig<TAbi, TFunctionName>): {
    data: import("@wagmi/core").SendTransactionResult | undefined;
    error: Error | null;
    isError: boolean;
    isIdle: boolean;
    isLoading: boolean;
    isSuccess: boolean;
    reset: () => void;
    status: "error" | "success" | "idle" | "loading";
    variables: UseContractWriteArgs<Abi, string> | undefined;
    write: ((overrideConfig?: UseContractWriteMutationArgs<typeof mode, TAbi, TFunctionName>) => void) | undefined;
    writeAsync: ((overrideConfig?: UseContractWriteMutationArgs<typeof mode, TAbi, TFunctionName>) => Promise<import("@wagmi/core").SendTransactionResult>) | undefined;
};
export {};
