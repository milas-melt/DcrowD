"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLog = void 0;
var core_1 = require("@moralisweb3/core");
var web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
var logDecoderUtils_1 = require("../utils/logDecoderUtils");
var parseLog = function (_a) {
    var webhookData = _a.webhookData, tag = _a.tag;
    if (!(0, logDecoderUtils_1.isWebhook)(webhookData)) {
        throw new core_1.MoralisStreamError({
            code: core_1.StreamErrorCode.GENERIC_STREAM_ERROR,
            message: 'Cannot decode the logs. No logs found in the webhook, or invalid webhook provided.',
        });
    }
    if (!(0, logDecoderUtils_1.hasAbis)(webhookData)) {
        throw new core_1.MoralisStreamError({
            code: core_1.StreamErrorCode.GENERIC_STREAM_ERROR,
            message: 'Cannot decode the logs. No abis found in the provided webhook.',
        });
    }
    var streamId = (0, logDecoderUtils_1.getTagStream)(webhookData, tag);
    if (!streamId) {
        throw new core_1.MoralisStreamError({
            code: core_1.StreamErrorCode.GENERIC_STREAM_ERROR,
            message: "Cannot decode the logs. No stream found for tag ".concat(tag, "."),
        });
    }
    if (!webhookData.abis[streamId]) {
        throw new core_1.MoralisStreamError({
            code: core_1.StreamErrorCode.GENERIC_STREAM_ERROR,
            message: "Cannot decode the logs. No abi found  for ".concat(streamId, "."),
        });
    }
    var logs = (0, logDecoderUtils_1.getTagLogs)(webhookData, tag);
    var decodedLogs = [];
    logs.forEach(function (currentLog) {
        var _a;
        if (!(0, logDecoderUtils_1.isContractLog)(currentLog, webhookData)) {
            return;
        }
        var _b = currentLog, data = _b.data, topic0 = _b.topic0;
        var abi = (_a = webhookData.abis) === null || _a === void 0 ? void 0 : _a[currentLog.streamId];
        var topics = [];
        if (abi.anonymous && (0, logDecoderUtils_1.isNotEmpty)(topic0)) {
            topics.push(topic0);
        }
        abi.inputs.forEach(function (_a) {
            var indexed = _a.indexed;
            var topicIndex = abi.anonymous ? topics.length : topics.length + 1;
            var log = currentLog;
            if (indexed && log["topic".concat(topicIndex)]) {
                topics.push(log["topic".concat(topicIndex)]);
            }
        });
        var decodedLog = web3_eth_abi_1.default.decodeLog(abi.inputs, data, topics);
        decodedLogs.push(decodedLog);
    });
    return decodedLogs;
};
exports.parseLog = parseLog;
//# sourceMappingURL=logParser.js.map