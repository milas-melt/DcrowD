"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BigNumberParser = void 0;
var Error_1 = require("../../Error");
var BigNumberParser = /** @class */ (function () {
    function BigNumberParser() {
    }
    BigNumberParser.parseInt = function (value) {
        assertNotEmpty(value);
        if (typeof value === 'string') {
            if (value.length === 0) {
                throw createError('Value is empty');
            }
            var isNegativeHex = value.startsWith('-0x');
            if (isNegativeHex) {
                value = value.substring(1);
            }
            var result = BigInt(value);
            if (isNegativeHex) {
                result *= BigInt(-1);
            }
            return result;
        }
        return BigInt(value);
    };
    // TODO: refactor to reduce complexity
    // eslint-disable-next-line complexity
    BigNumberParser.parseDecimal = function (value, decimals) {
        assertNotEmpty(value);
        var multiplier = getMultiplier(decimals);
        if (typeof value === 'number') {
            return BigInt(value) * multiplier;
        }
        if (typeof value === 'bigint') {
            return value * multiplier;
        }
        var isNegative = value.startsWith('-');
        if (isNegative) {
            value = value.substring(1);
        }
        var fragments = value.split('.');
        if (fragments.length > 2) {
            throw createError('Value has more than one dot');
        }
        if (fragments.some(function (fragment) { return !fragment; })) {
            throw createError('Value has empty fragments');
        }
        var result;
        if (fragments.length === 1) {
            result = BigInt(fragments[0]) * multiplier;
        }
        else {
            var whole = fragments[0];
            var fraction = fragments[1];
            if (fraction.length > decimals) {
                throw createError("Value has too long fractional part: ".concat(fraction.length, ", max: ").concat(decimals));
            }
            if (fraction.length < decimals) {
                fraction = fraction.padEnd(decimals, '0');
            }
            result = BigInt(whole) * multiplier + BigInt(fraction);
        }
        if (isNegative) {
            result *= BigInt(-1);
        }
        return result;
    };
    return BigNumberParser;
}());
exports.BigNumberParser = BigNumberParser;
function assertNotEmpty(value) {
    if (value === null) {
        throw createError('Value is null');
    }
    if (value === undefined) {
        throw createError('Value is undefined');
    }
}
function getMultiplier(decimals) {
    if (decimals < 0) {
        throw createError('Invalid decimals');
    }
    // decimals = 0, multiplier = 1
    // decimals = 1, multiplier = 10
    // decimals = 2, multiplier = 100
    // ...
    var ten = BigInt(10);
    var multiplier = BigInt(1);
    while (decimals-- > 0) {
        multiplier *= ten;
    }
    return multiplier;
}
function createError(message) {
    return new Error_1.MoralisCoreError({
        code: Error_1.CoreErrorCode.BIG_NUMBER_ERROR,
        message: message,
    });
}
//# sourceMappingURL=BigNumberParser.js.map