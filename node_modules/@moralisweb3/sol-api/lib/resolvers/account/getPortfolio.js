"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPortfolio = void 0;
var api_utils_1 = require("@moralisweb3/api-utils");
var sol_utils_1 = require("@moralisweb3/sol-utils");
var SolNetworkResolver_1 = require("../SolNetworkResolver");
exports.getPortfolio = (0, api_utils_1.createEndpointFactory)(function (core) {
    return (0, api_utils_1.createEndpoint)({
        name: 'getPortfolio',
        urlParams: ['network', 'address'],
        getUrl: function (params) {
            // TODO: here should be: const network = SolNetworkResolver.resolve(params.network, core);
            // but it's not working with Endpoints.getDescriptors(). After changes described in Endpoints
            // please replace this line.
            var network = params.network ? params.network : SolNetworkResolver_1.SolNetworkResolver.resolve(undefined, core);
            return "/account/".concat(network, "/").concat(params.address, "/portfolio");
        },
        apiToResult: function (data) {
            return {
                nativeBalance: sol_utils_1.SolNative.create(data.nativeBalance.lamports, 'lamports'),
                nfts: data.nfts.map(function (nft) {
                    return {
                        associatedTokenAddress: sol_utils_1.SolAddress.create(nft.associatedTokenAddress),
                        mint: sol_utils_1.SolAddress.create(nft.mint),
                    };
                }),
                tokens: data.tokens.map(function (token) {
                    return {
                        associatedTokenAddress: sol_utils_1.SolAddress.create(token.associatedTokenAddress),
                        mint: sol_utils_1.SolAddress.create(token.mint),
                        amount: sol_utils_1.SolNative.create(token.amountRaw, 'lamports'),
                    };
                }),
            };
        },
        resultToJson: function (data) {
            return {
                nativeBalance: data.nativeBalance.toJSON(),
                nfts: data.nfts.map(function (nft) {
                    return {
                        associatedTokenAddress: nft.associatedTokenAddress.toJSON(),
                        mint: nft.mint.toJSON(),
                    };
                }),
                tokens: data.tokens.map(function (token) {
                    return {
                        associatedTokenAddress: token.associatedTokenAddress.toJSON(),
                        mint: token.mint.toJSON(),
                        amount: token.amount.toJSON(),
                    };
                }),
            };
        },
        parseParams: function (params) { return ({
            network: SolNetworkResolver_1.SolNetworkResolver.resolve(params.network, core),
            address: sol_utils_1.SolAddress.create(params.address).address,
        }); },
    });
});
//# sourceMappingURL=getPortfolio.js.map