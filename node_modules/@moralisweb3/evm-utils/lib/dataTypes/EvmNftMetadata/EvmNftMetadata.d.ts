import { MoralisDataObject } from '@moralisweb3/core';
import { EvmAddress } from '../EvmAddress';
import { EvmChain } from '../EvmChain';
import { EvmNftMetadataInput, EvmNftMetadataData } from './types';
/**
 * This can be an exsisting {@link EvmNftMetadata} or a valid {@link EvmNftMetadataInput}.
 */
export declare type EvmNftMetadataish = EvmNftMetadataInput | EvmNftMetadata;
/**
 * The EvmNftMetadata contains metadata of an NFT.
 *
 * @category DataType
 */
export declare class EvmNftMetadata implements MoralisDataObject {
    /**
     *  Create a new instance of EvmNftMetadata from any valid EvmNftMetadata input
     *
     * @param data - the EvmNftMetadataish type
     * @example
     * ```ts
     * const token = EvmNftMetadataish.create(value);
     * ```
     */
    static create(data: EvmNftMetadataish): EvmNftMetadata;
    private _data;
    constructor(data: EvmNftMetadataInput);
    static parse: (data: EvmNftMetadataInput) => EvmNftMetadataData;
    /**
     * Compares two EvmNftMetadata instances. This checks if the chain and tokenAddress of both meatdatas are equal.
     *
     * @param dataA - the first EvmNftMetadataish to compare
     * @param dataB - the second EvmNftMetadataish to compare
     * @returns true if the two EvmNftMetadataData are equal
     * @example
     * ```ts
     * EvmNftMetadata.equals(dataA, dataB);
     * ```
     */
    static equals(dataA: EvmNftMetadataish, dataB: EvmNftMetadataish): boolean;
    /**
     * Compares EvmNftMetadata instance to current instance
     *
     * @param data - the EvmNftMetadataish to compare
     * @returns true if the EvmNftMetadataish is equals given metadata
     * @example
     * ```ts
     * metadata.equals(data);
     * ```
     */
    equals(data: EvmNftMetadataish): boolean;
    /**
     * @returns the data as JSON.
     * @example metadata.toJSON();
     */
    toJSON(): {
        chain: string | number;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @returns the data as JSON.
     * @example metadata.format();
     */
    format(): {
        chain: string | number;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example metadata.result;
     */
    get result(): EvmNftMetadataData;
    /**
     * @returns the name in the metadata.
     * @example metadata.name; // "Baby Ape Mutant Club"
     */
    get name(): string;
    /**
     * @returns the symbol in the metadata.
     * @example metadata.symbol; // "BAMC"
     */
    get symbol(): string;
    /**
     * @returns the contract type of the NFT.
     * @example metadata.contractType; // "ERC721"
     */
    get contractType(): string | undefined;
    /**
     * @returns the chain in the metadata.
     * @example metadata.chain; // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the token address in the metadata.
     * @example metadata.tokenAddress; // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the date the metadata was synced.
     * @example metadata.syncedAt; // Date
     */
    get syncedAt(): Date | undefined;
}
//# sourceMappingURL=EvmNftMetadata.d.ts.map