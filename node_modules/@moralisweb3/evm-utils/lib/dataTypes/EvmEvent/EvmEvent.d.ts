import { MoralisCore, MoralisDataObject, BigNumber } from '@moralisweb3/core';
import { EvmAddress } from '../EvmAddress';
import { EvmChain } from '../EvmChain';
import { EvmNative } from '../EvmNative';
import { EvmEventInput, EvmEventData } from './types';
/**
 * Valid input for a new EvmEvent instance.
 * This can be an existing {@link EvmEvent} or a valid {@link EvmEventInput} object
 */
export declare type EvmEventish = EvmEventInput | EvmEvent;
/**
 * The EvmEvent is a representation of an event.
 *
 * Use this class any time you work with an event.
 *
 * @category DataType
 */
export declare class EvmEvent implements MoralisDataObject {
    private readonly _data;
    /**
     * Create a new instance of EvmEvent from any valid event input
     * @param data - the EvmEventish type
     * @example
     * ```
     * const event = EvmEventish.create(data);
     *```
     */
    static create(data: EvmEventish, core?: MoralisCore): EvmEvent;
    private constructor();
    static parse: (data: EvmEventInput, core: MoralisCore) => EvmEventData;
    /**
     * Check the equality between two Evm events. It checks if the chain, block number, address and data are equal.
     * @param dataA - The first event
     * @param dataB - The second event
     * @example
     * ```ts
     * EvmEvent.equals(dataA, dataB)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    static equals(dataA: EvmEventish, dataB: EvmEventish): boolean;
    /**
     * Checks the equality of the current event instance with another evm event
     * @param data - the event to compare with
     * @example
     * ```ts
     * event.equals(data)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    equals(data: EvmEventish): boolean;
    /**
     * @returns a JSON represention of the event.
     * @example
     * ```
     * event.toJSON()
     * ```
     */
    toJSON(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @returns a JSON represention of the event.
     * @example event.format()
     */
    format(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example event.result
     */
    get result(): EvmEventData;
    /**
     * @returns the event chain
     * @example event.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the event address
     * @example event.address // EvmAddress
     */
    get address(): EvmAddress;
    /**
     * @returns the event block number
     * @example event.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the event block timestamp
     * @example event.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the event data with from address, to address and value
     * @example event.data
     */
    get data(): {
        from?: EvmAddress | undefined;
        to?: EvmAddress | undefined;
        value?: EvmNative | undefined;
    };
    /**
     * @returns the event block trannsaciton hash
     * @example event.transactionHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get transactionHash(): string;
    /**
     * @returns the event block hash
     * @example event.blockHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get blockHash(): string;
}
//# sourceMappingURL=EvmEvent.d.ts.map