import { Abi, AbiEvent, ExtractAbiEvent, ExtractAbiEventNames, Narrow } from 'abitype';
import { AbiEventParametersToPrimitiveTypes, Event } from '../../types/contracts';
import { IsNever, NotEqual, Or } from '../../types/utils';
declare type ContractEventConfig<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string = string> = {
    /** Contract address */
    address: string;
    /** Contract ABI */
    abi: Narrow<TAbi>;
    /** Chain id to use for provider */
    chainId?: number;
    /** Event to listen for */
    eventName: IsNever<TEventName> extends true ? string : TEventName;
    /** Receive only a single event */
    once?: boolean;
};
declare type GetConfig<T> = T extends {
    abi: infer TAbi extends Abi;
} ? ContractEventConfig<TAbi, ExtractAbiEventNames<TAbi>> : T extends {
    abi: infer TAbi extends readonly unknown[];
    eventName: infer TEventName extends string;
} ? ContractEventConfig<TAbi, TEventName> : ContractEventConfig;
export declare type WatchContractEventConfig<TAbi = Abi, TEventName = string> = GetConfig<{
    abi: TAbi;
    eventName: TEventName;
}>;
export declare type WatchContractEventCallback<TAbi extends Abi | readonly unknown[] = Abi, TEventName extends string = string, TAbiEvent extends AbiEvent = TAbi extends Abi ? ExtractAbiEvent<TAbi, TEventName> : never> = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs']> extends infer TArgs extends readonly unknown[] ? Or<IsNever<TArgs>, NotEqual<TAbi, Abi>> extends true ? (...args: any) => void : (...args: [...args: TArgs, event: Event<TAbiEvent>]) => void : never;
export declare function watchContractEvent<TAbi extends Abi | readonly unknown[], TEventName extends string>({ address, abi, chainId, eventName, once, }: WatchContractEventConfig<TAbi, TEventName>, callback: WatchContractEventCallback<TAbi, TEventName>): () => void;
export {};
